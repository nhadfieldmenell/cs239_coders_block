(dp0
S'imports'
p1
c__builtin__
set
p2
((lp3
tp4
Rp5
sS'code'
p6
S'class rbnode(object):\n    """\n    A node in a red black tree. See Cormen, Leiserson, Rivest, Stein 2nd edition pg 273.\n    """\n    \n    def __init__(self, key):\n        "Construct."\n        self._key = key\n        self._red = False\n        self._left = None\n        self._right = None\n        self._p = None\n    \n    key = property(fget=lambda self: self._key, doc="The node\'s key")\n    red = property(fget=lambda self: self._red, doc="Is the node red?")\n    left = property(fget=lambda self: self._left, doc="The node\'s left child")\n    right = property(fget=lambda self: self._right, doc="The node\'s right child")\n    p = property(fget=lambda self: self._p, doc="The node\'s parent")\n    \n    def __str__(self):\n        "String representation."\n        return str(self.key)\n    \n\n    def __repr__(self):\n        "String representation."\n        return str(self.key)\n    \n\n\n\n\n\n\n\n\nclass rbtree(object):\n    """\n    A red black tree. See Cormen, Leiserson, Rivest, Stein 2nd edition pg 273.\n    """\n    \n    \n    def __init__(self, create_node=rbnode):\n        "Construct."\n        \n        self._nil = create_node(key=None)\n        "Our nil node, used for all leaves."\n        \n        self._root = self.nil\n        "The root of the tree."\n        \n        self._create_node = create_node\n        "A callable that creates a node."\n\n\n    root = property(fget=lambda self: self._root, doc="The tree\'s root node")\n    nil = property(fget=lambda self: self._nil, doc="The tree\'s nil node")\n    \n    \n    def search(self, key, x=None):\n        """\n        Search the subtree rooted at x (or the root if not given) iteratively for the key.\n        \n        @return: self.nil if it cannot find it.\n        """\n        if None == x:\n            x = self.root\n        while x != self.nil and key != x.key:\n            if key < x.key:\n                x = x.left\n            else:\n                x = x.right\n        return x\n\n    \n    def minimum(self, x=None):\n        """\n        @return: The minimum value in the subtree rooted at x.\n        """\n        if None == x:\n            x = self.root\n        while x.left != self.nil:\n            x = x.left\n        return x\n\n    \n    def maximum(self, x=None):\n        """\n        @return: The maximum value in the subtree rooted at x.\n        """\n        if None == x:\n            x = self.root\n        while x.right != self.nil:\n            x = x.right\n        return x\n\n    \n    def insert_key(self, key):\n        "Insert the key into the tree."\n        self.insert_node(self._create_node(key=key))\n    \n    \n    def insert_node(self, z):\n        "Insert node z into the tree."\n        y = self.nil\n        x = self.root\n        while x != self.nil:\n            y = x\n            if z.key < x.key:\n                x = x.left\n            else:\n                x = x.right\n        z._p = y\n        if y == self.nil:\n            self._root = z\n        elif z.key < y.key:\n            y._left = z\n        else:\n            y._right = z\n        z._left = self.nil\n        z._right = self.nil\n        z._red = True\n        self._insert_fixup(z)\n        \n        \n    def _insert_fixup(self, z):\n        "Restore red-black properties after insert."\n        while z.p.red:\n            if z.p == z.p.p.left:\n                y = z.p.p.right\n                if y.red:\n                    z.p._red = False\n                    y._red = False\n                    z.p.p._red = True\n                    z = z.p.p\n                else:\n                    if z == z.p.right:\n                        z = z.p\n                        self._left_rotate(z)\n                    z.p._red = False\n                    z.p.p._red = True\n                    self._right_rotate(z.p.p)\n            else:\n                y = z.p.p.left\n                if y.red:\n                    z.p._red = False\n                    y._red = False\n                    z.p.p._red = True\n                    z = z.p.p\n                else:\n                    if z == z.p.left:\n                        z = z.p\n                        self._right_rotate(z)\n                    z.p._red = False\n                    z.p.p._red = True\n                    self._left_rotate(z.p.p)\n        self.root._red = False\n\n    \n    def _left_rotate(self, x):\n        "Left rotate x."\n        y = x.right\n        x._right = y.left'
p7
sS'methods'
p8
(lp9
S'property'
p10
ag10
ag10
ag10
ag10
ag10
ag10
aS'str'
p11
ag11
aS'create_node'
p12
aS'self.insert_node'
p13
aS'self._insert_fixup'
p14
aS'self._create_node'
p15
aS'self._right_rotate'
p16
aS'self._left_rotate'
p17
aS'self._left_rotate'
p18
aS'self._right_rotate'
p19
as.